<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Zombie Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="uiContainer" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; z-index: 100;">
        <div id="healthDisplay">Health: 100</div>
        <div id="scoreDisplay">Score: 0</div>
        <div id="weaponDisplay">Weapon: Pistol</div>
    </div>
    <div id="gameOverScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: Arial, sans-serif; text-align: center; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; z-index: 101;">
        <h2>Game Over</h2>
        <p id="finalScoreDisplay">Your Score: 0</p>
        <button id="restartButton">Restart Game</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game logic will go here
        console.log("Game logic script loaded.");

        // UI Element References
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const weaponDisplay = document.getElementById('weaponDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const restartButton = document.getElementById('restartButton');

        // 1. Get the canvas element
        const canvas = document.getElementById('gameCanvas');

        // 2. Create a WebGLRenderer
        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // 3. Create a Scene
        const scene = new THREE.Scene();
        const clock = new THREE.Clock(); // Clock for timed events

        // 4. Create a PerspectiveCamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Camera will be parented to player

        // 5. Add basic lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 1, 0);
        scene.add(directionalLight);

        // Create Player Group (acting as the player)
        const player = new THREE.Group();
        player.position.y = 0; // Pivot at the feet for the group
        scene.add(player);

        const playerBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Green

        // Player Body (Cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.0, 16); // radiusTop, radiusBottom, height, radialSegments
        const playerBody = new THREE.Mesh(bodyGeometry, playerBodyMaterial);
        playerBody.position.y = 0.5; // Half height, so it sits on y=0 of the group
        player.add(playerBody);

        // Player Head (Sphere)
        const headGeometry = new THREE.SphereGeometry(0.25, 16, 16); // radius, widthSegments, heightSegments
        const playerHead = new THREE.Mesh(headGeometry, playerBodyMaterial); // Can use same material
        playerHead.position.y = 1.0 + 0.25; // Position on top of the body (body height + head radius)
        player.add(playerHead);


        // Attach camera to player group
        player.add(camera);
        camera.position.set(0, 1.2, 0); // Eyes roughly at y=1.2 relative to player group's origin (feet)

        // Weapon Definitions
        const weaponTypes = {
            pistol: {
                name: 'Pistol',
                color: 0xff0000, // Projectile color
                fireRate: 500, // milliseconds per shot
                projectileSpeed: 0.8, // Increased speed
                pickupColor: 0xcccccc, // Color of the pickup box
                damage: 25 // Updated damage
            },
            machineGun: {
                name: 'Machine Gun',
                color: 0xffff00, // Yellow projectiles
                fireRate: 100, // Faster fire rate
                projectileSpeed: 1.0, // Increased speed
                pickupColor: 0x00ff00, // Green pickup box
                damage: 15 // Updated damage
            }
        };
        let currentPlayerWeapon = weaponTypes.pistol;
        let lastShotTime = 0;

        // Player Health & Score
        let playerHealth = 100;
        let score = 0; // Score variable added
        let isGameOver = false;

        // Projectile Variables
        const projectiles = [];
        const projectileGeometry = new THREE.SphereGeometry(0.15, 8, 8); // Global definition - Increased radius for visibility
        // const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // REMOVED - will be dynamic

        // Weapon Pickup Variables
        const weaponPickups = [];
        // pickupGeometry will be defined in spawnWeaponPickup based on type

        // Enemy Variables
        const enemies = [];
        // Enemy Geometry: Cylinder (radiusTop, radiusBottom, height, radialSegments)
        const enemyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red color for enemies
        let lastSpawnTime = 0;
        let spawnInterval = 5000; // milliseconds (5 seconds)
        const maxEnemies = 20;


        // Player Movement Variables
        const playerSpeed = 0.1;
        const keyboard = {};

        // Keyboard Event Listeners for Movement
        document.addEventListener('keydown', (event) => {
            keyboard[event.code] = true; // General key state update for movement
        });
        document.addEventListener('keyup', (event) => {
            keyboard[event.code] = false;
        });

        // Mouse Controls (Look and Shoot)
        const euler = new THREE.Euler(0, 0, 0, 'YXZ'); // To control camera rotation
        const PI_2 = Math.PI / 2; // For clamping pitch

        function onMouseMove(event) {
            if (document.pointerLockElement === canvas) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                // Rotate player (yaw)
                player.rotation.y -= movementX * 0.002;

                // Rotate camera (pitch)
                euler.setFromQuaternion(camera.quaternion);
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x)); // Clamp pitch
                camera.quaternion.setFromEuler(euler);
            }
        }

        document.addEventListener('mousemove', onMouseMove, false);

        // Listener for requesting pointer lock
        canvas.addEventListener('click', () => {
            if (document.pointerLockElement !== canvas) {
                 canvas.requestPointerLock();
            }
        });

        // Listener for shooting
        document.addEventListener('mousedown', (event) => {
            // Check if pointer is locked, game is not over, and it's the left mouse button (button code 0)
            if (document.pointerLockElement === canvas && !isGameOver && event.button === 0) {
                const currentTime = clock.getElapsedTime() * 1000;
                if (currentTime - lastShotTime < currentPlayerWeapon.fireRate) return;
                lastShotTime = currentTime;

                const currentProjectileMaterial = new THREE.MeshStandardMaterial({ color: currentPlayerWeapon.color });
                const projectile = new THREE.Mesh(projectileGeometry, currentProjectileMaterial);

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction); // Projectiles go where the camera is looking

                // Spawn projectile slightly in front of the camera, along its direction
                const spawnPosition = new THREE.Vector3();
                camera.getWorldPosition(spawnPosition); // Get camera's world position
                projectile.position.copy(spawnPosition).addScaledVector(direction, 1.0); // Spawn 1 unit in front of camera

                projectile.velocity = direction.multiplyScalar(currentPlayerWeapon.projectileSpeed);

                projectiles.push(projectile);
                scene.add(projectile);
            }
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                console.log('Pointer Lock active');
            } else {
                console.log('Pointer Lock released');
            }
        }, false);

        document.addEventListener('pointerlockerror', (event) => {
            console.error('Pointer Lock Error:', event);
        }, false);


        // Enemy Spawning Function
        function spawnEnemy() {
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.x = (Math.random() - 0.5) * 20;
            enemy.position.y = 0.6; // Half height of cylinder (1.2 / 2)
            enemy.position.z = (Math.random() - 0.5) * 20 - 10;
            enemy.health = 100; // Enemy health
            enemies.push(enemy);
            scene.add(enemy);
        }

        // Spawn Weapon Pickup Function
        function spawnWeaponPickup(weaponType) {
            let specificPickupGeometry;
            if (weaponType.name === weaponTypes.machineGun.name) {
                specificPickupGeometry = new THREE.BoxGeometry(0.5, 0.75, 0.5); // Taller box for MG
            } else { // Default for pistol and potentially others
                specificPickupGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            }

            const pickupMaterial = new THREE.MeshStandardMaterial({ color: weaponType.pickupColor });
            const pickupMesh = new THREE.Mesh(specificPickupGeometry, pickupMaterial);
            pickupMesh.position.x = (Math.random() - 0.5) * 15;
            // Adjust Y based on geometry height to sit on ground
            if (weaponType.name === weaponTypes.machineGun.name) {
                pickupMesh.position.y = 0.75 / 2;
            } else {
                pickupMesh.position.y = 0.5 / 2;
            }
            pickupMesh.position.z = (Math.random() - 0.5) * 15;
            pickupMesh.weaponType = weaponType;
            scene.add(pickupMesh);
            weaponPickups.push(pickupMesh);
        }

        // Initial Enemy Spawning
        for (let i = 0; i < 5; i++) {
            spawnEnemy();
        }
        // Initial Weapon Pickup Spawning
        spawnWeaponPickup(weaponTypes.machineGun);


        // 6. Create a simple render loop
        function animate() {
            if (isGameOver) {
                // Optional: Add a simple "Game Over" text update here later for UI
                return;
            }
            requestAnimationFrame(animate);

            // Update Player Position
            if (!isGameOver) {
                const moveDirection = new THREE.Vector3();
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();

                // Get player's forward direction (ignoring pitch from camera)
                // Player's rotation.y is the yaw.
                forward.set(Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y)).normalize();
                // Calculate right vector ( perpendicular to forward, in XZ plane)
                right.set(forward.z, 0, -forward.x).normalize();


                if (keyboard['ArrowUp'] || keyboard['KeyW']) {
                    moveDirection.sub(forward); // Move forward along player's facing direction
                }
                if (keyboard['ArrowDown'] || keyboard['KeyS']) {
                    moveDirection.add(forward); // Move backward
                }
                if (keyboard['ArrowLeft'] || keyboard['KeyA']) {
                    moveDirection.sub(right); // Strafe left
                }
                if (keyboard['ArrowRight'] || keyboard['KeyD']) {
                   moveDirection.add(right); // Strafe right
                }

                if (moveDirection.lengthSq() > 0) { // If there's any movement input
                    moveDirection.normalize().multiplyScalar(playerSpeed);
                    player.position.add(moveDirection);
                }
            }

            // Update Projectile Positions & Collision Detection
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity);

                let projectileRemoved = false; // Flag to check if projectile was removed by collision

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    const distance = p.position.distanceTo(enemy.position);
                    if (distance < 1) { // Projectile hits enemy
                        scene.remove(p);
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                        projectiles.splice(i, 1);
                        projectileRemoved = true; // Use the existing flag name 'projectileRemoved'

                        enemy.health -= currentPlayerWeapon.damage;
                        console.log("Enemy hit, health: " + enemy.health + ", Weapon Damage: " + currentPlayerWeapon.damage);

                        if (enemy.health <= 0) {
                            scene.remove(enemy);
                            if (enemy.geometry) enemy.geometry.dispose();
                            if (enemy.material) enemy.material.dispose();
                            enemies.splice(j, 1);
                            score += 100; // Add score
                            console.log("Enemy destroyed! Score: " + score);
                        }
                        break; // Projectile hits one enemy
                    }
                }

                if (!projectileRemoved && p.position.lengthSq() > 10000) { // Boundary check if not removed by collision
                    scene.remove(p);
                    if (p.geometry) p.geometry.dispose();
                    if (p.material) p.material.dispose();
                    projectiles.splice(i, 1);
                }
            }

            // Update Enemies & AI
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Simple AI: Move towards player
                const directionToPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
                // Keep enemy AI movement on the XZ plane, their Y position is fixed.
                directionToPlayer.y = 0;
                directionToPlayer.normalize();

                const enemySpeed = 0.01; // Adjust as needed
                enemy.position.addScaledVector(directionToPlayer, enemySpeed);
                // enemy.position.y is set at spawn and collision doesn't change it.

                // Make enemy face the player (optional, simple rotation)
                // enemy.lookAt(player.position.x, enemy.position.y, player.position.z); // LookAt player XZ
                // The above lookAt might conflict with existing rotation.y += 0.01 if not handled.
                // For now, let's keep the spinning or remove it if lookAt is preferred.
                // Removing spinning for now, as it looks odd with non-symmetrical models.
                // enemy.rotation.y += 0.01;
                // Alternative: Make enemy look at player (Y component of player.position should be enemy.position.y for correct lookAt)
                const lookAtPosition = new THREE.Vector3(player.position.x, enemy.position.y, player.position.z);
                enemy.lookAt(lookAtPosition);

                // Player-Enemy Collision
                const distanceToPlayer = player.position.distanceTo(enemy.position);
                if (distanceToPlayer < 1.0 && !isGameOver) { // Check !isGameOver here too
                    playerHealth -= 10;
                    console.log("Player hit by enemy! Health: " + playerHealth);

                    scene.remove(enemy); // Remove enemy that hit player
                    if (enemy.geometry) enemy.geometry.dispose();
                    if (enemy.material) enemy.material.dispose();
                    enemies.splice(i, 1); // Remove from array
                    console.log("Enemy that hit player removed.");

                    if (playerHealth <= 0) {
                        console.log("Game Over!");
                        isGameOver = true;
                        finalScoreDisplay.textContent = "Your Score: " + score;
                        gameOverScreen.style.display = 'block';
                    }
                }
            }

            // Enemy Spawning Logic
            if (!isGameOver) { // Check added for spawning
                const elapsedTime = clock.getElapsedTime() * 1000; // convert to milliseconds
                if (elapsedTime - lastSpawnTime > spawnInterval && enemies.length < maxEnemies) {
                    lastSpawnTime = elapsedTime;
                    spawnEnemy();

                    if (spawnInterval > 1000) { // Minimum spawn interval of 1 second
                        spawnInterval *= 0.95; // Decrease by 5% each time
                    }
                }
            }

            // Update UI (if not game over)
            if (!isGameOver) {
                healthDisplay.textContent = "Health: " + playerHealth;
                scoreDisplay.textContent = "Score: " + score;
                weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;
            }

            // Camera is now a child of player, so its position and rotation are relative.
            // No need for manual camera following code here. Player rotation handles Y-axis look.
            // Camera's own rotation handles X-axis look (pitch).

            // Player vs Weapon Pickup Collision
            for (let i = weaponPickups.length - 1; i >= 0; i--) {
                const pickup = weaponPickups[i];
                const distance = player.position.distanceTo(pickup.position);
                if (distance < 1) { // Player close enough to pickup
                    currentPlayerWeapon = pickup.weaponType;
                    console.log("Picked up " + currentPlayerWeapon.name);
                    scene.remove(pickup);
                    if (pickup.geometry) pickup.geometry.dispose();
                    if (pickup.material) pickup.material.dispose();
                    weaponPickups.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // 7. Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        restartButton.addEventListener('click', () => {
            // Reset game state variables
            playerHealth = 100;
            score = 0;
            isGameOver = false;
            currentPlayerWeapon = weaponTypes.pistol; // Reset to default weapon
            lastShotTime = 0;
            // Reset spawn timer base - ensure clock is running or reset elapsed time interpretation
            // Using clock.elapsedTime directly for lastSpawnTime after reset might be cleaner
            // For now, this keeps previous logic structure
            lastSpawnTime = clock.getElapsedTime() * 1000;
            spawnInterval = 5000; // Reset spawn interval

            // Clear existing enemies and projectiles
            projectiles.forEach(p => {
                scene.remove(p);
                if (p.geometry) p.geometry.dispose();
                if (p.material) p.material.dispose();
            });
            projectiles.length = 0;

            enemies.forEach(e => {
                scene.remove(e);
                if (e.geometry) e.geometry.dispose();
                if (e.material) e.material.dispose();
            });
            enemies.length = 0;

            weaponPickups.forEach(wp => {
                scene.remove(wp);
                if (wp.geometry) wp.geometry.dispose();
                if (wp.material) wp.material.dispose();
            });
            weaponPickups.length = 0;

            // Spawn initial enemies
            for (let i = 0; i < 5; i++) {
                spawnEnemy();
            }
            // Spawn initial weapon pickup(s)
            spawnWeaponPickup(weaponTypes.machineGun); // Ensure this function exists and is correct

            // Reset player position
            player.position.set(0, 0, 0); // Player group pivot is at feet (y=0)

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Update UI immediately for health/score/weapon
            healthDisplay.textContent = "Health: " + playerHealth;
            scoreDisplay.textContent = "Score: " + score;
            weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;

            // The animate() loop will continue due to requestAnimationFrame and isGameOver being false
        });
    </script>
</body>
</html>
