<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Zombie Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="uiContainer" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; z-index: 100;">
        <div id="healthDisplay">Health: 100</div>
        <div id="scoreDisplay">Score: 0</div>
        <div id="weaponDisplay">Weapon: Pistol</div>
    </div>
    <div id="gameOverScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: Arial, sans-serif; text-align: center; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; z-index: 101;">
        <h2>Game Over</h2>
        <p id="finalScoreDisplay">Your Score: 0</p>
        <button id="restartButton">Restart Game</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game logic will go here
        console.log("Game logic script loaded.");

        // UI Element References
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const weaponDisplay = document.getElementById('weaponDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const restartButton = document.getElementById('restartButton');

        // 1. Get the canvas element
        const canvas = document.getElementById('gameCanvas');

        // 2. Create a WebGLRenderer
        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // 3. Create a Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky-blue background
        const clock = new THREE.Clock(); // Clock for timed events

        // 4. Create a PerspectiveCamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Camera will be parented to player

        // 5. Add basic lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Increased intensity
        directionalLight.position.set(0, 1, 0);
        scene.add(directionalLight);

        // Create Ground Plane
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50, side: THREE.DoubleSide });
        const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
        groundPlane.position.y = 0; // Position at y = 0
        groundPlane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        scene.add(groundPlane);

        // Create Player Group (acting as the player)
        const player = new THREE.Group();
        player.position.y = 0; // Pivot at the feet for the group
        scene.add(player);

        const playerBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Green

        // Player Body (Cylinder - low-poly)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.0, 8); // radiusTop, radiusBottom, height, radialSegments
        const playerBody = new THREE.Mesh(bodyGeometry, playerBodyMaterial);
        playerBody.position.y = 0.5; // Half height, so bottom is at y=0 of the group
        player.add(playerBody);

        // Player Head (Sphere - low-poly)
        const headGeometry = new THREE.SphereGeometry(0.25, 8, 8); // radius, widthSegments, heightSegments
        const playerHead = new THREE.Mesh(headGeometry, playerBodyMaterial); // Can use same material
        playerHead.position.y = 1.0 + 0.25; // Position on top of the body (body height + head radius)
        player.add(playerHead);

        // Held Weapon Representation
        const heldWeaponGeo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
        const heldWeaponMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        player.userData.heldWeaponMesh = new THREE.Mesh(heldWeaponGeo, heldWeaponMat);
        player.userData.heldWeaponMesh.position.set(0.35, 0.5, 0.3); // Position in "hand"
        player.add(player.userData.heldWeaponMesh);

        // Attach camera to player group
        player.add(camera);
        camera.position.set(0, 1.2, 0); // Eyes roughly at y=1.2 relative to player group's origin (feet)

        // Weapon Definitions
        const weaponTypes = {
            pistol: {
                name: 'Pistol',
                color: 0xff0000, // Projectile color
                fireRate: 500, // milliseconds per shot
                projectileSpeed: 0.8, // Increased speed
                pickupColor: 0xcccccc, // Color of the pickup box
                damage: 25 // Updated damage
            },
            machineGun: {
                name: 'Machine Gun',
                color: 0xffff00, // Yellow projectiles
                fireRate: 100, // Faster fire rate
                projectileSpeed: 1.0, // Increased speed
                pickupColor: 0x00ff00, // Green pickup box
                damage: 15 // Updated damage
            }
        };
        let currentPlayerWeapon = weaponTypes.pistol;
        let lastShotTime = 0;

        // Player Health & Score
        let playerHealth = 100;
        let score = 0; // Score variable added
        let isGameOver = false;

        // Projectile Variables
        const projectiles = [];
        const projectileGeometry = new THREE.SphereGeometry(0.05, 8, 8); // Global definition - Reduced radius for smaller bullets
        // const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // REMOVED - will be dynamic

        // Weapon Pickup Variables
        const weaponPickups = [];
        // pickupGeometry will be defined in spawnWeaponPickup based on type

        // Enemy Variables
        const enemies = [];
        // Enemy Geometry: Cylinder (radiusTop, radiusBottom, height, radialSegments) - REPLACED
        // const enemyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red color for enemies
        let lastSpawnTime = 0;
        let spawnInterval = 5000; // milliseconds (5 seconds)
        const maxEnemies = 20;


        // Player Movement Variables
        const playerSpeed = 0.1;
        const keyboard = {};

        // Keyboard Event Listeners for Movement
        document.addEventListener('keydown', (event) => {
            keyboard[event.code] = true; // General key state update for movement
        });
        document.addEventListener('keyup', (event) => {
            keyboard[event.code] = false;
        });

        // Mouse Controls (Look and Shoot)
        const euler = new THREE.Euler(0, 0, 0, 'YXZ'); // To control camera rotation
        const PI_2 = Math.PI / 2; // For clamping pitch

        function onMouseMove(event) {
            if (document.pointerLockElement === canvas) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                // Rotate player (yaw)
                player.rotation.y -= movementX * 0.002;

                // Rotate camera (pitch)
                euler.setFromQuaternion(camera.quaternion);
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x)); // Clamp pitch
                camera.quaternion.setFromEuler(euler);
            }
        }

        document.addEventListener('mousemove', onMouseMove, false);

        // Listener for requesting pointer lock
        canvas.addEventListener('click', () => {
            if (document.pointerLockElement !== canvas) {
                 canvas.requestPointerLock();
            }
        });

        // Listener for shooting
        document.addEventListener('mousedown', (event) => {
            // Check if pointer is locked, game is not over, and it's the left mouse button (button code 0)
            if (document.pointerLockElement === canvas && !isGameOver && event.button === 0) {
                const currentTime = clock.getElapsedTime() * 1000;
                if (currentTime - lastShotTime < currentPlayerWeapon.fireRate) return;
                lastShotTime = currentTime;

                const currentProjectileMaterial = new THREE.MeshStandardMaterial({ color: currentPlayerWeapon.color });
                const projectile = new THREE.Mesh(projectileGeometry, currentProjectileMaterial);
                projectile.userData.boundingBox = new THREE.Box3().setFromObject(projectile); // Initialize bounding box

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction); // Projectiles go where the camera is looking

                // Spawn projectile slightly in front of the camera, along its direction
                const spawnPosition = new THREE.Vector3();
                camera.getWorldPosition(spawnPosition); // Get camera's world position
                projectile.position.copy(spawnPosition).addScaledVector(direction, 1.5); // Spawn 1.5 units in front of camera

                projectile.velocity = direction.multiplyScalar(currentPlayerWeapon.projectileSpeed);

                projectiles.push(projectile);
                scene.add(projectile);
            }
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                console.log('Pointer Lock active');
            } else {
                console.log('Pointer Lock released');
            }
        }, false);

        document.addEventListener('pointerlockerror', (event) => {
            console.error('Pointer Lock Error:', event);
        }, false);


        // Enemy Spawning Function
        function spawnEnemy() {
            const enemy = new THREE.Group(); // Enemies are now groups
            enemy.position.x = (Math.random() - 0.5) * 20;
            enemy.position.y = 0; // Base of the enemy group is on the ground
            enemy.position.z = (Math.random() - 0.5) * 20 - 10;

            const lowerBodyHeight = 0.7;
            const upperBodyHeight = 0.5;

            // Lower Body
            const lowerBodyGeo = new THREE.BoxGeometry(0.5, lowerBodyHeight, 0.5);
            const lowerBodyMesh = new THREE.Mesh(lowerBodyGeo, enemyMaterial);
            lowerBodyMesh.position.y = lowerBodyHeight / 2;
            enemy.add(lowerBodyMesh);

            // Upper Body / Head
            const upperBodyGeo = new THREE.BoxGeometry(0.4, upperBodyHeight, 0.4);
            const upperBodyMesh = new THREE.Mesh(upperBodyGeo, enemyMaterial);
            upperBodyMesh.position.y = lowerBodyHeight + (upperBodyHeight / 2);
            enemy.add(upperBodyMesh);

            enemy.health = 100; // Enemy health
            enemy.userData.boundingBox = new THREE.Box3().setFromObject(enemy); // Initialize bounding box
            enemies.push(enemy);
            scene.add(enemy);
        }

        // Spawn Weapon Pickup Function
        function spawnWeaponPickup(weaponType) {
            const pickupMaterial = new THREE.MeshStandardMaterial({ color: weaponType.pickupColor });
            const pickupGroup = new THREE.Group();

            // Define geometries for a generic gun shape
            const barrelGeo = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const handleGeo = new THREE.BoxGeometry(0.15, 0.25, 0.15);

            const barrelMesh = new THREE.Mesh(barrelGeo, pickupMaterial);
            barrelMesh.position.z = 0.2; // Position barrel forward
            pickupGroup.add(barrelMesh);

            const handleMesh = new THREE.Mesh(handleGeo, pickupMaterial);
            handleMesh.position.y = -0.05; // Position handle slightly down
            pickupGroup.add(handleMesh);

            const pickupMesh = pickupGroup; // Use the group as the main pickup object

            pickupMesh.position.x = (Math.random() - 0.5) * 15;
            pickupMesh.position.y = 0.125; // Fixed Y position for the gun model to sit on ground
            pickupMesh.position.z = (Math.random() - 0.5) * 15;

            pickupMesh.weaponType = weaponType;
            pickupMesh.userData.boundingBox = new THREE.Box3().setFromObject(pickupMesh); // Initialize bounding box

            scene.add(pickupMesh);
            weaponPickups.push(pickupMesh);
        }

        // Tree Spawning Function
        function spawnTree(x, z) {
            const tree = new THREE.Group();

            const trunkHeight = 1.5;
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, trunkHeight, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
            const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
            trunkMesh.position.y = trunkHeight / 2;
            tree.add(trunkMesh);

            const leavesHeight = 1.0; // Using Cone for leaves
            const leavesGeo = new THREE.ConeGeometry(0.7, leavesHeight, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest Green
            const leavesMesh = new THREE.Mesh(leavesGeo, leavesMat);
            leavesMesh.position.y = trunkHeight + leavesHeight / 2;
            tree.add(leavesMesh);

            tree.position.set(x, 0, z); // Base of the tree trunk on the ground
            scene.add(tree);
            // Future: Could add tree.userData.boundingBox if trees need interaction
        }

        // Rock Spawning Function
        function spawnRock(x, z) {
            const rockSize = Math.random() * 0.3 + 0.3; // Random size between 0.3 and 0.6
            // Using Icosahedron for a jagged look, can also use Dodecahedron or scaled Box
            const rockGeo = new THREE.IcosahedronGeometry(rockSize, 0);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x808080 }); // Grey
            const rockMesh = new THREE.Mesh(rockGeo, rockMat);

            rockMesh.position.set(x, rockSize / 2, z); // Bottom of the rock on the ground
            scene.add(rockMesh);
            // Future: Could add rockMesh.userData.boundingBox if rocks need interaction
        }

        // Initial Enemy Spawning
        for (let i = 0; i < 5; i++) {
            spawnEnemy();
        }
        // Initial Weapon Pickup Spawning
        spawnWeaponPickup(weaponTypes.machineGun);

        // Initial Environment Spawning
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * 90; // Spread across ground plane
            const z = (Math.random() - 0.5) * 90;
            if (x*x + z*z > 25) { // Avoid spawning too close to player start (0,0)
                 spawnTree(x, z);
            }
        }
        for (let i = 0; i < 15; i++) {
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            if (x*x + z*z > 16) { // Avoid spawning too close to player start (0,0)
                spawnRock(x, z);
            }
        }


        // 6. Create a simple render loop
        function animate() {
            if (isGameOver) {
                // Optional: Add a simple "Game Over" text update here later for UI
                return;
            }
            requestAnimationFrame(animate);

            // Update Player Position
            if (!isGameOver) {
                // Update player bounding box
                if (!player.userData.boundingBox) {
                    player.userData.boundingBox = new THREE.Box3();
                }
                player.userData.boundingBox.setFromObject(player);

                const moveDirection = new THREE.Vector3();
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();

                // Get player's forward direction (ignoring pitch from camera)
                // Player's rotation.y is the yaw.
                forward.set(Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y)).normalize();
                // Calculate right vector ( perpendicular to forward, in XZ plane)
                right.set(forward.z, 0, -forward.x).normalize();


                if (keyboard['ArrowUp'] || keyboard['KeyW']) {
                    moveDirection.sub(forward); // Move forward along player's facing direction
                }
                if (keyboard['ArrowDown'] || keyboard['KeyS']) {
                    moveDirection.add(forward); // Move backward
                }
                if (keyboard['ArrowLeft'] || keyboard['KeyA']) {
                    moveDirection.sub(right); // Strafe left
                }
                if (keyboard['ArrowRight'] || keyboard['KeyD']) {
                   moveDirection.add(right); // Strafe right
                }

                if (moveDirection.lengthSq() > 0) { // If there's any movement input
                    moveDirection.normalize().multiplyScalar(playerSpeed);
                    player.position.add(moveDirection);
                }
            }

            // Update Projectile Positions & Collision Detection
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity);
                p.userData.boundingBox.setFromObject(p); // Update projectile bounding box after moving

                let projectileRemoved = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    enemy.userData.boundingBox.setFromObject(enemy); // Update enemy bounding box

                    if (p.userData.boundingBox.intersectsBox(enemy.userData.boundingBox)) { // Projectile hits enemy
                        scene.remove(p);
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                        projectiles.splice(i, 1);
                        projectileRemoved = true;

                        enemy.health -= currentPlayerWeapon.damage;
                        console.log("Enemy hit, health: " + enemy.health + ", Weapon Damage: " + currentPlayerWeapon.damage);

                        if (enemy.health <= 0) {
                            scene.remove(enemy);
                            if (enemy.geometry) enemy.geometry.dispose();
                            if (enemy.material) enemy.material.dispose();
                            enemies.splice(j, 1);
                            score += 100; // Add score
                            console.log("Enemy destroyed! Score: " + score);
                        }
                        break;
                    }
                }

                if (!projectileRemoved && p.position.lengthSq() > 10000) { // Boundary check if not removed by collision
                    scene.remove(p);
                    if (p.geometry) p.geometry.dispose();
                    if (p.material) p.material.dispose();
                    projectiles.splice(i, 1);
                }
            }

            // Update Enemies & AI
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Simple AI: Move towards player
                const directionToPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
                // Keep enemy AI movement on the XZ plane, their Y position is fixed.
                directionToPlayer.y = 0;
                directionToPlayer.normalize();

                const enemySpeed = 0.01; // Adjust as needed
                enemy.position.addScaledVector(directionToPlayer, enemySpeed);
                // enemy.position.y is set at spawn and collision doesn't change it.

                // Update enemy bounding box after moving and before lookAt/collision
                enemy.userData.boundingBox.setFromObject(enemy);

                // Make enemy face the player (optional, simple rotation)
                const lookAtPosition = new THREE.Vector3(player.position.x, enemy.position.y, player.position.z);
                enemy.lookAt(lookAtPosition);

                // Player-Enemy Collision
                // Player's bounding box is updated at the start of animate loop.
                // Enemy's bounding box is updated above, after its movement.
                if (player.userData.boundingBox.intersectsBox(enemy.userData.boundingBox) && !isGameOver) {
                    playerHealth -= 10;
                    console.log("Player hit by enemy! Health: " + playerHealth);

                    scene.remove(enemy); // Remove enemy that hit player
                    if (enemy.geometry) enemy.geometry.dispose();
                    if (enemy.material) enemy.material.dispose();
                    enemies.splice(i, 1); // Remove from array
                    console.log("Enemy that hit player removed.");

                    if (playerHealth <= 0) {
                        console.log("Game Over!");
                        isGameOver = true;
                        finalScoreDisplay.textContent = "Your Score: " + score;
                        gameOverScreen.style.display = 'block';
                    }
                }
            }

            // Enemy Spawning Logic
            if (!isGameOver) { // Check added for spawning
                const elapsedTime = clock.getElapsedTime() * 1000; // convert to milliseconds
                if (elapsedTime - lastSpawnTime > spawnInterval && enemies.length < maxEnemies) {
                    lastSpawnTime = elapsedTime;
                    spawnEnemy();

                    if (spawnInterval > 1000) { // Minimum spawn interval of 1 second
                        spawnInterval *= 0.95; // Decrease by 5% each time
                    }
                }
            }

            // Update UI (if not game over)
            if (!isGameOver) {
                healthDisplay.textContent = "Health: " + playerHealth;
                scoreDisplay.textContent = "Score: " + score;
                weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;
            }

            // Camera is now a child of player, so its position and rotation are relative.
            // No need for manual camera following code here. Player rotation handles Y-axis look.
            // Camera's own rotation handles X-axis look (pitch).

            // Player vs Weapon Pickup Collision
            for (let i = weaponPickups.length - 1; i >= 0; i--) {
                const pickup = weaponPickups[i];
                // Update pickup's bounding box (good practice, though they are static for now)
                // Ensure boundingBox was initialized at spawn
                if (pickup.userData.boundingBox) {
                    pickup.userData.boundingBox.setFromObject(pickup);
                } else {
                    // Fallback or error if boundingBox wasn't initialized
                    console.warn("Weapon pickup missing boundingBox:", pickup);
                    // As a simple fallback for this case, we could use distance check,
                    // or skip collision, or initialize it here (less ideal).
                    // For now, let's assume it was initialized.
                }

                if (player.userData.boundingBox && pickup.userData.boundingBox &&
                    player.userData.boundingBox.intersectsBox(pickup.userData.boundingBox)) {
                    currentPlayerWeapon = pickup.weaponType;
                    console.log("Picked up " + currentPlayerWeapon.name);

                    // Proper disposal for groups: remove children and their geometries/materials
                    while(pickup.children.length > 0){
                        const child = pickup.children[0];
                        pickup.remove(child); // Remove child from group
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                    // If the pickup itself had a material (e.g. if it wasn't a group before)
                    if (pickup.material) pickup.material.dispose();
                    // If the pickup itself had a geometry (e.g. if it wasn't a group before)
                    if (pickup.geometry) pickup.geometry.dispose();

                    scene.remove(pickup); // Remove the group itself from the scene
                    weaponPickups.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // 7. Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        restartButton.addEventListener('click', () => {
            // Reset game state variables
            playerHealth = 100;
            score = 0;
            isGameOver = false;
            currentPlayerWeapon = weaponTypes.pistol; // Reset to default weapon
            lastShotTime = 0;
            // Reset spawn timer base - ensure clock is running or reset elapsed time interpretation
            // Using clock.elapsedTime directly for lastSpawnTime after reset might be cleaner
            // For now, this keeps previous logic structure
            lastSpawnTime = clock.getElapsedTime() * 1000;
            spawnInterval = 5000; // Reset spawn interval

            // Clear existing enemies and projectiles
            projectiles.forEach(p => {
                scene.remove(p);
                if (p.geometry) p.geometry.dispose();
                if (p.material) p.material.dispose();
            });
            projectiles.length = 0;

            enemies.forEach(e => {
                scene.remove(e);
                if (e.geometry) e.geometry.dispose();
                if (e.material) e.material.dispose();
            });
            enemies.length = 0;

            weaponPickups.forEach(wp => {
                scene.remove(wp);
                if (wp.geometry) wp.geometry.dispose();
                if (wp.material) wp.material.dispose();
            });
            weaponPickups.length = 0;

            // Spawn initial enemies
            for (let i = 0; i < 5; i++) {
                spawnEnemy();
            }
            // Spawn initial weapon pickup(s)
            spawnWeaponPickup(weaponTypes.machineGun); // Ensure this function exists and is correct

            // Reset player position
            player.position.set(0, 0, 0); // Player group pivot is at feet (y=0)

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Update UI immediately for health/score/weapon
            healthDisplay.textContent = "Health: " + playerHealth;
            scoreDisplay.textContent = "Score: " + score;
            weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;

            // The animate() loop will continue due to requestAnimationFrame and isGameOver being false
        });
    </script>
</body>
</html>
