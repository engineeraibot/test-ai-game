<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Zombie Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="uiContainer" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; z-index: 100;">
        <div id="healthDisplay">Health: 100</div>
        <div id="scoreDisplay">Score: 0</div>
        <div id="weaponDisplay">Weapon: Pistol</div>
    </div>
    <div id="gameOverScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: Arial, sans-serif; text-align: center; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; z-index: 101;">
        <h2>Game Over</h2>
        <p id="finalScoreDisplay">Your Score: 0</p>
        <button id="restartButton">Restart Game</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game logic will go here
        console.log("Game logic script loaded.");

        // UI Element References
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const weaponDisplay = document.getElementById('weaponDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const restartButton = document.getElementById('restartButton');

        // 1. Get the canvas element
        const canvas = document.getElementById('gameCanvas');

        // 2. Create a WebGLRenderer
        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // 3. Create a Scene
        const scene = new THREE.Scene();
        const clock = new THREE.Clock(); // Clock for timed events

        // 4. Create a PerspectiveCamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5; // Initial camera Z, will be overridden by follow logic

        // 5. Add basic lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 1, 0);
        scene.add(directionalLight);

        // Create Player Mesh
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 0.5; // Initial Y position
        scene.add(player);

        // Weapon Definitions
        const weaponTypes = {
            pistol: {
                name: 'Pistol',
                color: 0xff0000, // Projectile color
                fireRate: 500, // milliseconds per shot
                projectileSpeed: 0.5,
                pickupColor: 0xcccccc, // Color of the pickup box
                damage: 25 // Updated damage
            },
            machineGun: {
                name: 'Machine Gun',
                color: 0xffff00, // Yellow projectiles
                fireRate: 100, // Faster fire rate
                projectileSpeed: 0.7,
                pickupColor: 0x00ff00, // Green pickup box
                damage: 15 // Updated damage
            }
        };
        let currentPlayerWeapon = weaponTypes.pistol;
        let lastShotTime = 0;

        // Player Health & Score
        let playerHealth = 100;
        let score = 0; // Score variable added
        let isGameOver = false;

        // Projectile Variables
        const projectiles = [];
        const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8); // Global definition
        // const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // REMOVED - will be dynamic

        // Weapon Pickup Variables
        const weaponPickups = [];
        const pickupGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5); // Global definition


        // Enemy Variables
        const enemies = [];
        const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        let lastSpawnTime = 0;
        let spawnInterval = 5000; // milliseconds (5 seconds)
        const maxEnemies = 20;


        // Player Movement Variables
        const playerSpeed = 0.1;
        const keyboard = {};

        // Keyboard Event Listeners
        document.addEventListener('keydown', (event) => {
            keyboard[event.code] = true; // General key state update

            if (event.code === 'Space') {
                if (isGameOver) return; // Stop shooting if game over
                const currentTime = clock.getElapsedTime() * 1000;
                if (currentTime - lastShotTime < currentPlayerWeapon.fireRate) return;
                lastShotTime = currentTime;

                const currentProjectileMaterial = new THREE.MeshStandardMaterial({ color: currentPlayerWeapon.color });
                const projectile = new THREE.Mesh(projectileGeometry, currentProjectileMaterial);

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                projectile.position.copy(player.position).addScaledVector(direction, 1.5); // Spawn 1.5 units in front
                projectile.velocity = direction.multiplyScalar(currentPlayerWeapon.projectileSpeed);

                projectiles.push(projectile);
                scene.add(projectile);
            }
        });
        document.addEventListener('keyup', (event) => {
            keyboard[event.code] = false;
        });

        // Enemy Spawning Function
        function spawnEnemy() {
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.x = (Math.random() - 0.5) * 20;
            enemy.position.y = 0.5;
            enemy.position.z = (Math.random() - 0.5) * 20 - 10;
            enemy.health = 100; // Enemy health
            enemies.push(enemy);
            scene.add(enemy);
        }

        // Spawn Weapon Pickup Function
        function spawnWeaponPickup(weaponType) {
            const pickupMaterial = new THREE.MeshStandardMaterial({ color: weaponType.pickupColor });
            const pickupMesh = new THREE.Mesh(pickupGeometry, pickupMaterial);
            pickupMesh.position.x = (Math.random() - 0.5) * 15;
            pickupMesh.position.y = 0.25;
            pickupMesh.position.z = (Math.random() - 0.5) * 15;
            pickupMesh.weaponType = weaponType;
            scene.add(pickupMesh);
            weaponPickups.push(pickupMesh);
        }

        // Initial Enemy Spawning
        for (let i = 0; i < 5; i++) {
            spawnEnemy();
        }
        // Initial Weapon Pickup Spawning
        spawnWeaponPickup(weaponTypes.machineGun);


        // 6. Create a simple render loop
        function animate() {
            if (isGameOver) {
                // Optional: Add a simple "Game Over" text update here later for UI
                return;
            }
            requestAnimationFrame(animate);

            // Update Player Position
            if (!isGameOver) { // Check added for movement block
                if (keyboard['ArrowUp'] || keyboard['KeyW']) {
                    player.position.z -= playerSpeed;
                }
                if (keyboard['ArrowDown'] || keyboard['KeyS']) {
                    player.position.z += playerSpeed;
                }
                if (keyboard['ArrowLeft'] || keyboard['KeyA']) {
                    player.position.x -= playerSpeed;
                }
                if (keyboard['ArrowRight'] || keyboard['KeyD']) {
                   player.position.x += playerSpeed;
                } // This brace closes the ArrowRight/KeyD if
            } // THIS IS THE ADDED CLOSING BRACE

            // Update Projectile Positions & Collision Detection
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity);

                let projectileRemoved = false; // Flag to check if projectile was removed by collision

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    const distance = p.position.distanceTo(enemy.position);
                    if (distance < 1) { // Projectile hits enemy
                        scene.remove(p);
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                        projectiles.splice(i, 1);
                        projectileRemoved = true; // Use the existing flag name 'projectileRemoved'

                        enemy.health -= currentPlayerWeapon.damage;
                        console.log("Enemy hit, health: " + enemy.health + ", Weapon Damage: " + currentPlayerWeapon.damage);

                        if (enemy.health <= 0) {
                            scene.remove(enemy);
                            if (enemy.geometry) enemy.geometry.dispose();
                            if (enemy.material) enemy.material.dispose();
                            enemies.splice(j, 1);
                            score += 100; // Add score
                            console.log("Enemy destroyed! Score: " + score);
                        }
                        break; // Projectile hits one enemy
                    }
                }

                if (!projectileRemoved && p.position.lengthSq() > 10000) { // Boundary check if not removed by collision
                    scene.remove(p);
                    if (p.geometry) p.geometry.dispose();
                    if (p.material) p.material.dispose();
                    projectiles.splice(i, 1);
                }
            }

            // Update Enemies & AI
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Simple AI: Move towards player
                const directionToPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
                directionToPlayer.y = 0; // Project onto XZ plane
                directionToPlayer.normalize();

                const enemySpeed = 0.01; // Adjust as needed
                enemy.position.addScaledVector(directionToPlayer, enemySpeed);
                enemy.position.y = 0.5; // Ensure it stays on the ground

                enemy.rotation.y += 0.01; // Keep spinning for now

                // Player-Enemy Collision
                const distanceToPlayer = player.position.distanceTo(enemy.position);
                if (distanceToPlayer < 1.0 && !isGameOver) { // Check !isGameOver here too
                    playerHealth -= 10;
                    console.log("Player hit by enemy! Health: " + playerHealth);

                    scene.remove(enemy); // Remove enemy that hit player
                    if (enemy.geometry) enemy.geometry.dispose();
                    if (enemy.material) enemy.material.dispose();
                    enemies.splice(i, 1); // Remove from array
                    console.log("Enemy that hit player removed.");

                    if (playerHealth <= 0) {
                        console.log("Game Over!");
                        isGameOver = true;
                        finalScoreDisplay.textContent = "Your Score: " + score;
                        gameOverScreen.style.display = 'block';
                    }
                }
            }

            // Enemy Spawning Logic
            if (!isGameOver) { // Check added for spawning
                const elapsedTime = clock.getElapsedTime() * 1000; // convert to milliseconds
                if (elapsedTime - lastSpawnTime > spawnInterval && enemies.length < maxEnemies) {
                    lastSpawnTime = elapsedTime;
                    spawnEnemy();

                    if (spawnInterval > 1000) { // Minimum spawn interval of 1 second
                        spawnInterval *= 0.95; // Decrease by 5% each time
                    }
                }
            }

            // Update UI (if not game over)
            if (!isGameOver) {
                healthDisplay.textContent = "Health: " + playerHealth;
                scoreDisplay.textContent = "Score: " + score;
                weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;
            }

            // Adjust Camera to Follow Player
            camera.position.set(player.position.x, player.position.y + 5, player.position.z + 5);
            camera.lookAt(player.position);

            // Player vs Weapon Pickup Collision
            for (let i = weaponPickups.length - 1; i >= 0; i--) {
                const pickup = weaponPickups[i];
                const distance = player.position.distanceTo(pickup.position);
                if (distance < 1) { // Player close enough to pickup
                    currentPlayerWeapon = pickup.weaponType;
                    console.log("Picked up " + currentPlayerWeapon.name);
                    scene.remove(pickup);
                    if (pickup.geometry) pickup.geometry.dispose();
                    if (pickup.material) pickup.material.dispose();
                    weaponPickups.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // 7. Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        restartButton.addEventListener('click', () => {
            // Reset game state variables
            playerHealth = 100;
            score = 0;
            isGameOver = false;
            currentPlayerWeapon = weaponTypes.pistol; // Reset to default weapon
            lastShotTime = 0;
            // Reset spawn timer base - ensure clock is running or reset elapsed time interpretation
            // Using clock.elapsedTime directly for lastSpawnTime after reset might be cleaner
            // For now, this keeps previous logic structure
            lastSpawnTime = clock.getElapsedTime() * 1000;
            spawnInterval = 5000; // Reset spawn interval

            // Clear existing enemies and projectiles
            projectiles.forEach(p => {
                scene.remove(p);
                if (p.geometry) p.geometry.dispose();
                if (p.material) p.material.dispose();
            });
            projectiles.length = 0;

            enemies.forEach(e => {
                scene.remove(e);
                if (e.geometry) e.geometry.dispose();
                if (e.material) e.material.dispose();
            });
            enemies.length = 0;

            weaponPickups.forEach(wp => {
                scene.remove(wp);
                if (wp.geometry) wp.geometry.dispose();
                if (wp.material) wp.material.dispose();
            });
            weaponPickups.length = 0;

            // Spawn initial enemies
            for (let i = 0; i < 5; i++) {
                spawnEnemy();
            }
            // Spawn initial weapon pickup(s)
            spawnWeaponPickup(weaponTypes.machineGun); // Ensure this function exists and is correct

            // Reset player position
            player.position.set(0, 0.5, 0);

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Update UI immediately for health/score/weapon
            healthDisplay.textContent = "Health: " + playerHealth;
            scoreDisplay.textContent = "Score: " + score;
            weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;

            // The animate() loop will continue due to requestAnimationFrame and isGameOver being false
        });
    </script>
</body>
</html>
