<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Zombie Shooter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="uiContainer" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; z-index: 100;">
        <div id="healthDisplay">Health: 100</div>
        <div id="scoreDisplay">Score: 0</div>
        <div id="weaponDisplay">Weapon: Pistol</div>
    </div>
    <div id="gameOverScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: Arial, sans-serif; text-align: center; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; z-index: 101;">
        <h2>Game Over</h2>
        <p id="finalScoreDisplay">Your Score: 0</p>
        <button id="restartButton">Restart Game</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game logic will go here
        console.log("Game logic script loaded.");

        // UI Element References
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const weaponDisplay = document.getElementById('weaponDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const restartButton = document.getElementById('restartButton');

        // 1. Get the canvas element
        const canvas = document.getElementById('gameCanvas');

        // 2. Create a WebGLRenderer
        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // 3. Create a Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky-blue background
        const clock = new THREE.Clock(); // Clock for timed events

        // 4. Create a PerspectiveCamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Camera will be parented to player

        // 5. Add basic lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Increased intensity
        directionalLight.position.set(0, 1, 0);
        scene.add(directionalLight);

        // Create Ground Plane with segments for terrain
        const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20); // Added segments
        const vertices = groundGeometry.attributes.position;
        for (let i = 0; i < vertices.count; i++) {
            const x = vertices.getX(i);
            const y = vertices.getY(i); // This y is one of the plane's dimensions before rotation
            // Modify the Z component of each vertex (which becomes world Y after rotation)
            vertices.setZ(i, (Math.random() - 0.5) * 2); // Random height between -1 and 1
        }
        groundGeometry.computeVertexNormals(); // Important for lighting

        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50, side: THREE.DoubleSide });
        const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
        // groundPlane.position.y = 0; // Y position will be inherent from vertex modification if centered.
        groundPlane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        scene.add(groundPlane);

        // Raycaster for terrain height calculation
        const raycaster = new THREE.Raycaster();

        function getTerrainHeight(worldX, worldZ) {
            if (!groundPlane) return 0;

            const rayOrigin = new THREE.Vector3(worldX, 50, worldZ); // Start high enough
            const rayDirection = new THREE.Vector3(0, -1, 0);
            raycaster.set(rayOrigin, rayDirection);

            const intersects = raycaster.intersectObject(groundPlane, false);

            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            return 0; // Default if no intersection
        }

        // Create Player Group (acting as the player)
        const player = new THREE.Group();
        player.position.set(0, getTerrainHeight(0, 0), 0); // Set initial Y based on terrain
        scene.add(player);

        const playerBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Green

        // Player Body (Cylinder - low-poly)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.0, 8); // radiusTop, radiusBottom, height, radialSegments
        const playerBody = new THREE.Mesh(bodyGeometry, playerBodyMaterial);
        playerBody.position.y = 0.5; // Half height, so bottom is at y=0 of the group
        player.add(playerBody);

        // Player Head (Sphere - low-poly)
        const headGeometry = new THREE.SphereGeometry(0.25, 8, 8); // radius, widthSegments, heightSegments
        const playerHead = new THREE.Mesh(headGeometry, playerBodyMaterial); // Can use same material
        playerHead.position.y = 1.0 + 0.25; // Position on top of the body (body height + head radius)
        player.add(playerHead);

        // Held Weapon Representation
        const heldWeaponGeo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
        const heldWeaponMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        player.userData.heldWeaponMesh = new THREE.Mesh(heldWeaponGeo, heldWeaponMat);
        player.userData.heldWeaponMesh.position.set(0.35, 0.5, 0.3); // Position in "hand"
        player.add(player.userData.heldWeaponMesh);

        // Attach camera to player group
        player.add(camera);
        camera.position.set(0, 1.2, 0); // Eyes roughly at y=1.2 relative to player group's origin (feet)

        // Weapon Definitions
        const weaponTypes = {
            pistol: {
                name: 'Pistol',
                color: 0xff0000, // Projectile color
                fireRate: 500, // milliseconds per shot
                projectileSpeed: 1.2, // Increased speed
                pickupColor: 0xcccccc, // Color of the pickup box
                damage: 25 // Updated damage
            },
            machineGun: {
                name: 'Machine Gun',
                color: 0xffff00, // Yellow projectiles
                fireRate: 100, // Faster fire rate
                projectileSpeed: 1.5, // Increased speed
                pickupColor: 0x00ff00, // Green pickup box
                damage: 15 // Updated damage
            }
        };
        let currentPlayerWeapon = weaponTypes.pistol;
        let lastShotTime = 0;

        // Player Health & Score
        let playerHealth = 100;
        let score = 0; // Score variable added
        let isGameOver = false;

        // Projectile Variables
        const projectiles = [];
        const projectileGeometry = new THREE.SphereGeometry(0.05, 8, 8); // Global definition - Reduced radius for smaller bullets
        // const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // REMOVED - will be dynamic

        // Weapon Pickup Variables
        const weaponPickups = [];
        // pickupGeometry will be defined in spawnWeaponPickup based on type

        // Enemy Variables
        const enemies = [];
        const activeExplosions = []; // Array for active explosions
        const castleParts = []; // Array for collidable castle parts
        // Enemy Geometry: Cylinder (radiusTop, radiusBottom, height, radialSegments) - REPLACED
        // const enemyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red color for enemies
        let lastSpawnTime = 0;
        let spawnInterval = 5000; // milliseconds (5 seconds)
        const maxEnemies = 20;


        // Player Movement Variables
        const playerSpeed = 0.1;
        const keyboard = {};

        // Keyboard Event Listeners for Movement
        document.addEventListener('keydown', (event) => {
            keyboard[event.code] = true; // General key state update for movement
        });
        document.addEventListener('keyup', (event) => {
            keyboard[event.code] = false;
        });

        // Mouse Controls (Look and Shoot)
        const euler = new THREE.Euler(0, 0, 0, 'YXZ'); // To control camera rotation
        const PI_2 = Math.PI / 2; // For clamping pitch

        function onMouseMove(event) {
            if (document.pointerLockElement === canvas) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                // Rotate player (yaw)
                player.rotation.y -= movementX * 0.002;

                // Rotate camera (pitch)
                euler.setFromQuaternion(camera.quaternion);
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x)); // Clamp pitch
                camera.quaternion.setFromEuler(euler);
            }
        }

        document.addEventListener('mousemove', onMouseMove, false);

        // Listener for requesting pointer lock
        canvas.addEventListener('click', () => {
            if (document.pointerLockElement !== canvas) {
                 canvas.requestPointerLock();
            }
        });

        // Create Explosion Function
        function createExplosion(position, color) {
            const particleCount = 20;
            const particles = new THREE.BufferGeometry();
            const pMaterial = new THREE.PointsMaterial({
                color: color || 0xFF0000, // Default to red, can pass enemy color
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending // For a brighter effect
            });

            const particlePositions = [];
            const particleVelocities = [];

            for (let i = 0; i < particleCount; i++) {
                particlePositions.push(position.x, position.y + 0.5, position.z); // Start at enemy center

                const vx = (Math.random() - 0.5) * 0.5; // Random velocity
                const vy = (Math.random() - 0.5) * 0.5;
                const vz = (Math.random() - 0.5) * 0.5;
                particleVelocities.push(vx, vy, vz);
            }

            particles.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));

            const particleSystem = new THREE.Points(particles, pMaterial);
            particleSystem.userData.velocities = particleVelocities;
            particleSystem.userData.life = 1.0; // How long the explosion lasts (e.g., 1 second)
            particleSystem.userData.startTime = clock.getElapsedTime();

            scene.add(particleSystem);
            activeExplosions.push(particleSystem);
        }

        // Listener for shooting
        document.addEventListener('mousedown', (event) => {
            // Check if pointer is locked, game is not over, and it's the left mouse button (button code 0)
            if (document.pointerLockElement === canvas && !isGameOver && event.button === 0) {
                const currentTime = clock.getElapsedTime() * 1000;
                if (currentTime - lastShotTime < currentPlayerWeapon.fireRate) return;
                lastShotTime = currentTime;

                const currentProjectileMaterial = new THREE.MeshStandardMaterial({ color: currentPlayerWeapon.color });
                const projectile = new THREE.Mesh(projectileGeometry, currentProjectileMaterial);
                projectile.userData.boundingBox = new THREE.Box3().setFromObject(projectile); // Initialize bounding box

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction); // Aiming direction from camera

                const spawnPosition = new THREE.Vector3();
                const cameraWorldPosition = new THREE.Vector3();
                camera.getWorldPosition(cameraWorldPosition);

                const weaponTipWorldPosition = new THREE.Vector3();
                player.userData.heldWeaponMesh.getWorldPosition(weaponTipWorldPosition);

                // Calculate the vector from the camera to the weapon tip
                const vectorFromCameraToWeaponTip = new THREE.Vector3().subVectors(weaponTipWorldPosition, cameraWorldPosition);

                // Project this vector onto the camera's line of sight to find the distance along the sightline
                // to a point perpendicular to the weapon's tip.
                const projectionDistance = vectorFromCameraToWeaponTip.dot(direction);

                // Spawn the projectile along the camera's sightline at this projected distance,
                // plus a small offset to ensure it clears the "virtual" tip of the gun.
                // The gun's actual model length is 0.4, so 0.2 is a reasonable offset to represent its "tip" from its center.
                // We use projectionDistance to ensure it's at the correct depth relative to the camera.
                // A small positive value like 0.1 ensures it spawns slightly in front of this projected point.
                spawnPosition.copy(cameraWorldPosition).addScaledVector(direction, projectionDistance + 0.1);


                projectile.position.copy(spawnPosition);
                projectile.velocity = direction.normalize().multiplyScalar(currentPlayerWeapon.projectileSpeed);

                projectiles.push(projectile);
                scene.add(projectile);
            }
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                console.log('Pointer Lock active');
            } else {
                console.log('Pointer Lock released');
            }
        }, false);

        document.addEventListener('pointerlockerror', (event) => {
            console.error('Pointer Lock Error:', event);
        }, false);


        // Enemy Spawning Function
        function spawnEnemy() {
            const enemy = new THREE.Group(); // Enemies are now groups
            enemy.position.x = (Math.random() - 0.5) * 20;
            enemy.position.z = (Math.random() - 0.5) * 20 - 10;
            enemy.position.y = getTerrainHeight(enemy.position.x, enemy.position.z); // Set Y based on terrain

            const lowerBodyHeight = 0.7;
            const upperBodyHeight = 0.5;

            // Lower Body
            const lowerBodyGeo = new THREE.BoxGeometry(0.5, lowerBodyHeight, 0.5);
            const lowerBodyMesh = new THREE.Mesh(lowerBodyGeo, enemyMaterial);
            lowerBodyMesh.position.y = lowerBodyHeight / 2;
            enemy.add(lowerBodyMesh);

            // Upper Body / Head
            const upperBodyGeo = new THREE.BoxGeometry(0.4, upperBodyHeight, 0.4);
            const upperBodyMesh = new THREE.Mesh(upperBodyGeo, enemyMaterial);
            upperBodyMesh.position.y = lowerBodyHeight + (upperBodyHeight / 2);
            enemy.add(upperBodyMesh);

            enemy.health = 100; // Enemy health
            enemy.userData.boundingBox = new THREE.Box3().setFromObject(enemy); // Initialize bounding box
            enemies.push(enemy);
            scene.add(enemy);
        }

        // Spawn Weapon Pickup Function
        function spawnWeaponPickup(weaponType) {
            const pickupMaterial = new THREE.MeshStandardMaterial({ color: weaponType.pickupColor });
            const pickupGroup = new THREE.Group();

            // Define geometries for a generic gun shape
            const barrelGeo = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const handleGeo = new THREE.BoxGeometry(0.15, 0.25, 0.15);

            const barrelMesh = new THREE.Mesh(barrelGeo, pickupMaterial);
            barrelMesh.position.z = 0.2; // Position barrel forward
            pickupGroup.add(barrelMesh);

            const handleMesh = new THREE.Mesh(handleGeo, pickupMaterial);
            handleMesh.position.y = -0.05; // Position handle slightly down
            pickupGroup.add(handleMesh);

            const pickupMesh = pickupGroup; // Use the group as the main pickup object

            pickupMesh.position.x = (Math.random() - 0.5) * 15;
            pickupMesh.position.z = (Math.random() - 0.5) * 15;
            pickupMesh.position.y = getTerrainHeight(pickupMesh.position.x, pickupMesh.position.z) + 0.125; // Adjust Y for terrain

            pickupMesh.weaponType = weaponType;
            pickupMesh.userData.boundingBox = new THREE.Box3().setFromObject(pickupMesh); // Initialize bounding box

            scene.add(pickupMesh);
            weaponPickups.push(pickupMesh);
        }

        // Tree Spawning Function
        function spawnTree(x, z) {
            const tree = new THREE.Group();

            const trunkHeight = 1.5;
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, trunkHeight, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
            const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
            trunkMesh.position.y = trunkHeight / 2;
            tree.add(trunkMesh);

            const leavesHeight = 1.0; // Using Cone for leaves
            const leavesGeo = new THREE.ConeGeometry(0.7, leavesHeight, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest Green
            const leavesMesh = new THREE.Mesh(leavesGeo, leavesMat);
            leavesMesh.position.y = trunkHeight + leavesHeight / 2;
            tree.add(leavesMesh);

            tree.position.set(x, 0, z); // Set X and Z first
            tree.position.y = getTerrainHeight(x, z); // Then set Y based on terrain
            scene.add(tree);
            // Future: Could add tree.userData.boundingBox if trees need interaction
        }

        // Rock Spawning Function
        function spawnRock(x, z) {
            const rockSize = Math.random() * 0.3 + 0.3; // Random size between 0.3 and 0.6
            // Using Icosahedron for a jagged look, can also use Dodecahedron or scaled Box
            const rockGeo = new THREE.IcosahedronGeometry(rockSize, 0);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x808080 }); // Grey
            const rockMesh = new THREE.Mesh(rockGeo, rockMat);

            rockMesh.position.set(x, 0, z); // Set X and Z first
            rockMesh.position.y = getTerrainHeight(x, z) + rockSize / 2; // Adjust Y for terrain and rock size
            scene.add(rockMesh);
            // Future: Could add rockMesh.userData.boundingBox if rocks need interaction
        }

        function createCastle() {
            const castleGroup = new THREE.Group(); // Parent group for the castle
            // Ensure groundPlane is available for getTerrainHeight, otherwise default Y or error
            if (!groundPlane) {
                console.error("groundPlane not initialized before createCastle() call. Castle may not sit on terrain correctly.");
            }

            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x7A7A7A, metalness: 0.2, roughness: 0.9 }); // Stone grey

            // Define castle base position to easily move the whole structure
            const castleBaseX = 0;
            const castleBaseZ = -30; // Position the castle further away

            // Helper function to get terrain height or default
            function getSafeTerrainHeight(x, z) {
                if (typeof getTerrainHeight === 'function') {
                    return getTerrainHeight(x, z);
                }
                return 0; // Default if terrain function not ready
            }

            // Main Wall
            const mainWallGeo = new THREE.BoxGeometry(12, 5, 1.5); // width, height, depth
            const mainWall = new THREE.Mesh(mainWallGeo, wallMaterial);
            const mainWallPosX = castleBaseX;
            const mainWallPosZ = castleBaseZ;
            mainWall.position.set(mainWallPosX, getSafeTerrainHeight(mainWallPosX, mainWallPosZ) + 2.5, mainWallPosZ); // + half height
            mainWall.userData.isCastlePart = true;
            mainWall.userData.boundingBox = new THREE.Box3().setFromObject(mainWall);
            castleGroup.add(mainWall);
            castleParts.push(mainWall);

            // Left Tower
            const towerGeo = new THREE.CylinderGeometry(2, 2, 7, 16); // radiusTop, radiusBottom, height, segments
            const leftTower = new THREE.Mesh(towerGeo, wallMaterial);
            const leftTowerPosX = castleBaseX - 7; // Offset from mainWall center
            const leftTowerPosZ = castleBaseZ;
            leftTower.position.set(leftTowerPosX, getSafeTerrainHeight(leftTowerPosX, leftTowerPosZ) + 3.5, leftTowerPosZ); // + half height
            leftTower.userData.isCastlePart = true;
            leftTower.userData.boundingBox = new THREE.Box3().setFromObject(leftTower);
            castleGroup.add(leftTower);
            castleParts.push(leftTower);

            // Right Tower
            const rightTower = new THREE.Mesh(towerGeo, wallMaterial);
            const rightTowerPosX = castleBaseX + 7; // Offset from mainWall center
            const rightTowerPosZ = castleBaseZ;
            rightTower.position.set(rightTowerPosX, getSafeTerrainHeight(rightTowerPosX, rightTowerPosZ) + 3.5, rightTowerPosZ); // + half height
            rightTower.userData.isCastlePart = true;
            rightTower.userData.boundingBox = new THREE.Box3().setFromObject(rightTower);
            castleGroup.add(rightTower);
            castleParts.push(rightTower);

            // Optional: A front gate structure (visual, can be made collidable too)
            const gateGeo = new THREE.BoxGeometry(4, 3, 1);
            const gate = new THREE.Mesh(gateGeo, wallMaterial);
            const gatePosX = castleBaseX;
            const gatePosZ = castleBaseZ + 1.25; // Slightly in front of the main wall
            gate.position.set(gatePosX, getSafeTerrainHeight(gatePosX, gatePosZ) + 1.5, gatePosZ);
            gate.userData.isCastlePart = true; // Make it collidable
            gate.userData.boundingBox = new THREE.Box3().setFromObject(gate);
            castleGroup.add(gate);
            castleParts.push(gate);

            scene.add(castleGroup); // Add the whole castle to the scene
        }

        // Initial Enemy Spawning
        for (let i = 0; i < 5; i++) {
            spawnEnemy();
        }
        // Initial Weapon Pickup Spawning
        spawnWeaponPickup(weaponTypes.machineGun);

        // Initial Environment Spawning
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * 90; // Spread across ground plane
            const z = (Math.random() - 0.5) * 90;
            if (x*x + z*z > 25) { // Avoid spawning too close to player start (0,0)
                 spawnTree(x, z);
            }
        }
        for (let i = 0; i < 15; i++) {
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            if (x*x + z*z > 16) { // Avoid spawning too close to player start (0,0)
                spawnRock(x, z);
            }
        }
        createCastle(); // Create the castle after other environment


        // 6. Create a simple render loop
        function animate() {
            if (isGameOver) {
                // Optional: Add a simple "Game Over" text update here later for UI
                return;
            }
            requestAnimationFrame(animate);

            // Update Player Position
            if (!isGameOver) {
                // Update player bounding box
                if (!player.userData.boundingBox) {
                    player.userData.boundingBox = new THREE.Box3();
                }
                player.userData.boundingBox.setFromObject(player);

                const moveDirection = new THREE.Vector3();
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();

                // Get player's forward direction (ignoring pitch from camera)
                // Player's rotation.y is the yaw.
                forward.set(Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y)).normalize();
                // Calculate right vector ( perpendicular to forward, in XZ plane)
                right.set(forward.z, 0, -forward.x).normalize();


                if (keyboard['ArrowUp'] || keyboard['KeyW']) {
                    moveDirection.sub(forward); // Move forward along player's facing direction
                }
                if (keyboard['ArrowDown'] || keyboard['KeyS']) {
                    moveDirection.add(forward); // Move backward
                }
                if (keyboard['ArrowLeft'] || keyboard['KeyA']) {
                    moveDirection.sub(right); // Strafe left
                }
                if (keyboard['ArrowRight'] || keyboard['KeyD']) {
                   moveDirection.add(right); // Strafe right
                }

                if (moveDirection.lengthSq() > 0) { // If there's any movement input
                    moveDirection.normalize().multiplyScalar(playerSpeed);
                    player.position.add(moveDirection);
                }
                player.position.y = getTerrainHeight(player.position.x, player.position.z); // Adjust player Y to terrain
            }

            // Update Projectile Positions & Collision Detection
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity);
                p.userData.boundingBox.setFromObject(p); // Update projectile bounding box after moving

                let projectileRemoved = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    enemy.userData.boundingBox.setFromObject(enemy); // Update enemy bounding box

                    if (p.userData.boundingBox.intersectsBox(enemy.userData.boundingBox)) { // Projectile hits enemy
                        scene.remove(p);
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                        projectiles.splice(i, 1);
                        projectileRemoved = true;

                        enemy.health -= currentPlayerWeapon.damage;
                        console.log("Enemy hit, health: " + enemy.health + ", Weapon Damage: " + currentPlayerWeapon.damage);

                        if (enemy.health <= 0) {
                            createExplosion(enemy.position.clone(), enemyMaterial.color.getHex()); // Call explosion here

                            // Corrected disposal for enemy (which is a THREE.Group)
                            while(enemy.children.length > 0){
                                const child = enemy.children[0];
                                enemy.remove(child);
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) child.material.dispose();
                            }
                            scene.remove(enemy); // Remove the group itself after children are handled

                            enemies.splice(j, 1);
                            score += 100; // Add score
                            console.log("Enemy destroyed! Score: " + score);
                        }
                        break;
                    }
                }

                // Projectile vs Castle Collision
                if (!projectileRemoved) { // Only check castle collision if not already hit an enemy
                    for (let k = castleParts.length - 1; k >= 0; k--) {
                        const part = castleParts[k];
                        // Ensure both projectile and castle part have bounding boxes initialized
                        if (p.userData.boundingBox && part.userData.boundingBox && p.userData.boundingBox.intersectsBox(part.userData.boundingBox)) {
                            scene.remove(p);
                            if (p.geometry) p.geometry.dispose();
                            if (p.material) p.material.dispose();
                            projectiles.splice(i, 1);
                            projectileRemoved = true; // Mark projectile as removed
                            // Optional: Add a visual/audio cue for hitting the castle
                            // console.log("Projectile hit castle part");
                            break; // Exit castle parts loop since projectile is removed
                        }
                    }
                }

                if (!projectileRemoved && p.position.lengthSq() > 10000) { // Boundary check if not removed by collision
                    scene.remove(p);
                    if (p.geometry) p.geometry.dispose();
                    if (p.material) p.material.dispose();
                    projectiles.splice(i, 1);
                }
            }

            // Update Active Explosions
            for (let i = activeExplosions.length - 1; i >= 0; i--) {
                const explosion = activeExplosions[i];
                const positions = explosion.geometry.attributes.position.array;
                const velocities = explosion.userData.velocities;
                // let stillAlive = false; // stillAlive was not used, removed.

                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] += velocities[j] * 0.1; // Adjust speed factor as needed
                    positions[j+1] += velocities[j+1] * 0.1;
                    positions[j+2] += velocities[j+2] * 0.1;

                    // Simple gravity for particles
                    velocities[j+1] -= 0.01; // Gravity effect
                }
                explosion.geometry.attributes.position.needsUpdate = true;

                // Fade out and remove
                const elapsedTime = clock.getElapsedTime() - explosion.userData.startTime;
                if (elapsedTime < explosion.userData.life) {
                    explosion.material.opacity = 1.0 - (elapsedTime / explosion.userData.life);
                    // stillAlive = true; // stillAlive was not used, removed.
                } else {
                    scene.remove(explosion);
                    if (explosion.geometry) explosion.geometry.dispose();
                    if (explosion.material) explosion.material.dispose();
                    activeExplosions.splice(i, 1);
                }
            }

            // Update Enemies & AI
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Simple AI: Move towards player
                const directionToPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
                // Keep enemy AI movement on the XZ plane, their Y position is fixed.
                directionToPlayer.y = 0;
                directionToPlayer.normalize();

                const enemySpeed = 0.01; // Adjust as needed
                enemy.position.addScaledVector(directionToPlayer, enemySpeed);
                enemy.position.y = getTerrainHeight(enemy.position.x, enemy.position.z); // Adjust enemy Y to terrain

                // Update enemy bounding box after moving and before lookAt/collision
                enemy.userData.boundingBox.setFromObject(enemy);

                // Make enemy face the player
                // Player's approximate head/torso height is player.position.y + 1.0 to 1.2
                const targetLookAt = new THREE.Vector3(player.position.x, player.position.y + 1.0, player.position.z);
                enemy.lookAt(targetLookAt);

                // Player-Enemy Collision
                // Player's bounding box is updated at the start of animate loop.
                // Enemy's bounding box is updated above, after its movement.
                if (player.userData.boundingBox.intersectsBox(enemy.userData.boundingBox) && !isGameOver) {
                    playerHealth -= 10;
                    console.log("Player hit by enemy! Health: " + playerHealth);

                    // Corrected disposal for enemy (which is a THREE.Group)
                    while(enemy.children.length > 0){
                        const child = enemy.children[0];
                        enemy.remove(child);
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                    scene.remove(enemy); // Remove the group itself after children are handled

                    enemies.splice(i, 1); // Remove from array
                    console.log("Enemy that hit player removed.");

                    if (playerHealth <= 0) {
                        console.log("Game Over!");
                        isGameOver = true;
                        finalScoreDisplay.textContent = "Your Score: " + score;
                        gameOverScreen.style.display = 'block';
                    }
                }
            }

            // Enemy Spawning Logic
            if (!isGameOver) { // Check added for spawning
                const elapsedTime = clock.getElapsedTime() * 1000; // convert to milliseconds
                if (elapsedTime - lastSpawnTime > spawnInterval && enemies.length < maxEnemies) {
                    lastSpawnTime = elapsedTime;
                    spawnEnemy();

                    if (spawnInterval > 1000) { // Minimum spawn interval of 1 second
                        spawnInterval *= 0.95; // Decrease by 5% each time
                    }
                }
            }

            // Update UI (if not game over)
            if (!isGameOver) {
                healthDisplay.textContent = "Health: " + playerHealth;
                scoreDisplay.textContent = "Score: " + score;
                weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;
            }

            // Camera is now a child of player, so its position and rotation are relative.
            // No need for manual camera following code here. Player rotation handles Y-axis look.
            // Camera's own rotation handles X-axis look (pitch).

            // Player vs Weapon Pickup Collision
            for (let i = weaponPickups.length - 1; i >= 0; i--) {
                const pickup = weaponPickups[i];
                // Update pickup's bounding box (good practice, though they are static for now)
                // Ensure boundingBox was initialized at spawn
                if (pickup.userData.boundingBox) {
                    pickup.userData.boundingBox.setFromObject(pickup);
                } else {
                    // Fallback or error if boundingBox wasn't initialized
                    console.warn("Weapon pickup missing boundingBox:", pickup);
                    // As a simple fallback for this case, we could use distance check,
                    // or skip collision, or initialize it here (less ideal).
                    // For now, let's assume it was initialized.
                }

                if (player.userData.boundingBox && pickup.userData.boundingBox &&
                    player.userData.boundingBox.intersectsBox(pickup.userData.boundingBox)) {
                    currentPlayerWeapon = pickup.weaponType;
                    console.log("Picked up " + currentPlayerWeapon.name);

                    // Proper disposal for groups: remove children and their geometries/materials
                    while(pickup.children.length > 0){
                        const child = pickup.children[0];
                        pickup.remove(child); // Remove child from group
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                    // If the pickup itself had a material (e.g. if it wasn't a group before)
                    if (pickup.material) pickup.material.dispose();
                    // If the pickup itself had a geometry (e.g. if it wasn't a group before)
                    if (pickup.geometry) pickup.geometry.dispose();

                    scene.remove(pickup); // Remove the group itself from the scene
                    weaponPickups.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // 7. Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        restartButton.addEventListener('click', () => {
            // Reset game state variables
            playerHealth = 100;
            score = 0;
            isGameOver = false;
            currentPlayerWeapon = weaponTypes.pistol; // Reset to default weapon
            lastShotTime = 0;
            // Reset spawn timer base - ensure clock is running or reset elapsed time interpretation
            // Using clock.elapsedTime directly for lastSpawnTime after reset might be cleaner
            // For now, this keeps previous logic structure
            lastSpawnTime = clock.getElapsedTime() * 1000;
            spawnInterval = 5000; // Reset spawn interval

            // Clear existing enemies and projectiles
            projectiles.forEach(p => {
                scene.remove(p);
                if (p.geometry) p.geometry.dispose();
                if (p.material) p.material.dispose();
            });
            projectiles.length = 0;

            enemies.forEach(e => {
                // Corrected disposal for enemy (which is a THREE.Group) in reset
                while(e.children.length > 0){
                    const child = e.children[0];
                    e.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
                scene.remove(e);
            });
            enemies.length = 0;

            activeExplosions.forEach(exp => {
                scene.remove(exp);
                if (exp.geometry) exp.geometry.dispose();
                if (exp.material) exp.material.dispose();
            });
            activeExplosions.length = 0;

            weaponPickups.forEach(wp => {
                // Corrected disposal for weapon pickups (which are Groups) in reset
                while(wp.children.length > 0){
                    const child = wp.children[0];
                    wp.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
                scene.remove(wp);
            });
            weaponPickups.length = 0;

            // Spawn initial enemies
            for (let i = 0; i < 5; i++) {
                spawnEnemy();
            }
            // Spawn initial weapon pickup(s)
            spawnWeaponPickup(weaponTypes.machineGun); // Ensure this function exists and is correct

            // Reset player position
            player.position.set(0, getTerrainHeight(0,0), 0); // Adjust Y for terrain

            // Hide game over screen
            gameOverScreen.style.display = 'none';

            // Update UI immediately for health/score/weapon
            healthDisplay.textContent = "Health: " + playerHealth;
            scoreDisplay.textContent = "Score: " + score;
            weaponDisplay.textContent = "Weapon: " + currentPlayerWeapon.name;

            // The animate() loop will continue due to requestAnimationFrame and isGameOver being false
        });
    </script>
</body>
</html>
